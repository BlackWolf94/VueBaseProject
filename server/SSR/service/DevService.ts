import {INestApplication, Injectable, Logger} from '@nestjs/common';
import {FileHelper} from '../../helper/FileHelper';
import chokidar from 'chokidar';
import {WpClient} from '../../../build/webpack/client.conf';
import webpack, {HotModuleReplacementPlugin, Stats} from 'webpack';
import * as path from 'path';
import {WpServe} from '../../../build/webpack/server.conf';
import MFS from 'memory-fs';

export type TOnReady = (bunble: any, options: any) => void;

@Injectable()
export class DevService {

    get app(): INestApplication {
        return (this.constructor as any).app;
    }

    public static instant(app: INestApplication) {
        this.app = app;
    }

    private static app: INestApplication;
    public mfs: MFS;
    public devMiddleware: any;
    private ready: (value?: unknown) => void;

    private bundle: any;
    private manifest: any;
    private template: any;

    constructor(private templatePath: string, private onReadyCb: TOnReady) {
    }


    public async compile(): Promise<any> {
        const compile = new Promise((res) => {
            this.ready = res;
        });

        this.template = await FileHelper.readFile(this.templatePath, 'utf-8');
        chokidar.watch(this.templatePath)
            .on('change', this.updateTemplatePath.bind(this));

        (WpClient.entry as any).app = ['webpack-hot-middleware/client', (WpClient.entry as any).app];
        WpClient.output.filename = '[name].js';
        WpClient.plugins.push(
            new HotModuleReplacementPlugin(),
        );
        WpClient.optimization.noEmitOnErrors = true;

        // dev middleware
        const clientCompiler = webpack(WpClient);
        this.devMiddleware = require('webpack-dev-middleware')(clientCompiler, {
            publicPath: WpClient.output.publicPath,
            noInfo: true,
        });

        this.app.use(this.devMiddleware);
        clientCompiler.hooks.done.tap('dev server', this.updateManifest.bind(this));
        this.update();
        // hot middleware
        this.app.use(require('webpack-hot-middleware')(clientCompiler, {heartbeat: 5000}));

        // watch and update server renderer
        const serverCompiler = webpack(WpServe);
        this.mfs = new MFS();
        serverCompiler.outputFileSystem = this.mfs;
        serverCompiler.watch({}, this.updateServ.bind(this));

        return compile;
    }

    private update() {
        if (!this.manifest || !this.bundle) {
            return;
        }

        this.onReadyCb(this.bundle, {
            template: this.template,
            clientManifest: this.manifest,
        });
        Logger.debug('Update SSR bundle', 'SSR DEV SERVER');
        this.ready();
    }


    private async updateTemplatePath() {
        this.template = await FileHelper.readFile(this.templatePath, 'utf-8');
        this.update();
    }


    private readFile = (fileSystem: any, file: string) => {
        try {
            return fileSystem.readFileSync(path.join(WpClient.output.path, file), 'utf-8');
        } catch (e) {
            throw e;
        }
    }

    private async updateManifest(stats: Stats) {
        stats.compilation.errors.forEach(console.error);
        stats.compilation.warnings.forEach(console.warn);

        if (stats.hasErrors()) {
            return;
        }

        this.manifest = JSON.parse(this.readFile(
            this.devMiddleware.fileSystem,
            'vue-ssr-client-manifest.json',
        ));
        this.update();
    }

    private updateServ(err: any, stats: any) {
        if (err) {
            throw err;
        }
        stats = stats.toJson();
        if (stats.errors.length) {
            return;
        }

        // read bundle generated by vue-ssr-webpack-plugin
        this.bundle = JSON.parse(this.readFile(this.mfs, 'vue-ssr-server-bundle.json'));
        this.update();
    }
}
